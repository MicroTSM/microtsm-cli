import {
  ConfigEnv,
  defineConfig as viteDefineConfig,
  UserConfig,
  UserConfigExport,
  UserConfigFn,
  UserConfigFnObject,
  UserConfigFnPromise,
} from 'vite';
import path from 'path';
import getAppName from './getAppName';

const CONFIG_MARKER = Symbol.for('MicroTSM-CLI.defineConfig');

export function isDefinedWithDefineConfig(config: UserConfig | undefined): boolean {
  return !!config && !!(config as any)[CONFIG_MARKER];
}

/**
 * Custom `defineConfig` wrapper for `@microtsm/cli`.
 *
 * This function wraps Vite's native `defineConfig`, providing automatic enhancements
 * tailored for MicroApp development using `single-spa`.
 *
 * ðŸ”§ Features:
 * - Extends user-supplied Vite config with:
 *   - `__APP_NAME__` global define from `package.json` name
 *   - Auto-enabled `manifest` output
 *   - Static output naming conventions for `entryFileNames` and `chunkFileNames`
 *   - Default Rollup `input` fallback (`src/main.ts`)
 * - Injects useful external dependencies for MicroFrontend (`vue`, `vue-router`, etc.)
 * - Adds HTTPS support using local certificates (via `@vitejs/plugin-basic-ssl`)
 * - Forces ESM format output with hashed chunks
 *
 * ðŸš« Limitations:
 * - Certain Vite options like `build.manifest`, `rollupOptions.output`, or `external` may be overwritten
 * - Not intended for generic use â€” this wrapper is opinionated for single-spa architecture
 * - HTTPS certificate paths are currently hardcoded; consider making them configurable
 *
 * ðŸ“¦ Supported config formats:
 * - Object config: `defineConfig({...})`
 * - Promise config: `defineConfig(async () => ({...}))`
 * - Function config with env: `defineConfig((env) => ({...}))`
 *
 * ðŸ§ª Example:
 * ```ts
 * import { defineConfig } from "@microtsm/cli";
 *
 * export default defineConfig(({ mode }) => ({
 *   plugins: [],
 *   define: {
 *     __FEATURE_FLAG__: JSON.stringify(true)
 *   },
 * }));
 * ```
 *
 * @param config - User's Vite config object, function, or promise
 * @returns Transformed Vite config with single-spa-specific enhancements
 */
export function defineConfig(config: UserConfig): UserConfig;
export function defineConfig(config: Promise<UserConfig>): Promise<UserConfig>;
export function defineConfig(config: UserConfigFnObject): UserConfigFnObject;
export function defineConfig(config: UserConfigFnPromise): UserConfigFnPromise;
export function defineConfig(config: UserConfigFn): UserConfigFn;
export function defineConfig(userConfig: UserConfigExport): UserConfigExport {
  const appName = getAppName();
  process.env.__APP_NAME__ = appName;

  const generateConfig = (config: UserConfig): UserConfig => {
    const { external } = config.build?.rollupOptions ?? {};

    const builtConfig = viteDefineConfig({
      ...config,
      define: { ...config.define, __APP_NAME__: JSON.stringify(appName) },
      build: {
        ...config.build,
        manifest: 'manifest.json',
        sourcemap: false,
        rollupOptions: {
          ...(config.build?.rollupOptions || {}),
          input: config.build?.rollupOptions?.input || path.resolve('src/main.ts'),
          output: {
            format: 'es',
            entryFileNames: 'js/app.js',
            chunkFileNames: 'js/chunk-[hash].js',
            ...(config.build?.rollupOptions?.output ?? {}),
          },
          external:
            !external || Array.isArray(external)
              ? ['vue', 'vue-router', 'axios', 'single-spa-vue', 'single-spa', ...(external || [])]
              : external,
        },
      },
    });

    // To mark the config as being generated by this function
    Object.defineProperty(builtConfig, CONFIG_MARKER, { value: true });

    return builtConfig;
  };

  if (typeof userConfig === 'function') {
    return ((env: ConfigEnv) => {
      const result = userConfig(env);
      return result instanceof Promise ? result.then(generateConfig) : generateConfig(result);
    }) as UserConfigFn;
  }

  if (userConfig instanceof Promise) {
    return userConfig.then(generateConfig);
  }

  return generateConfig(userConfig);
}
